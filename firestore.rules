/**
 * @file firestore.rules
 * @description Firestore Security Rules for a portfolio website with an admin panel.
 *
 * @section Core Philosophy
 * This ruleset implements a Role-Based Access Control (RBAC) model. A user's administrative
 * status is determined by the existence of their UID in the /roles_admin collection.
 * Public-facing content (portfolio projects, blog posts) is readable by anyone, but can
 * only be written or modified by authenticated administrators. Sensitive data, like
 * contact messages, is strictly controlled and only accessible by administrators.
 *
 * @section Data Structure
 * The data is organized into top-level collections for clear separation of concerns:
 * - /portfolioProjects: Publicly readable project data.
 * - /blogPosts: Publicly readable blog articles.
 * - /contactMessages: Private messages submitted via the website's contact form.
 * - /roles_admin: A special collection that acts as a lookup table for admin roles.
 *
 * @section Key Security Decisions
 * - Admin Role Management: The /roles_admin collection is the single source of truth for
 *   admin privileges. To prevent privilege escalation, this collection is read-only from
 *   the client side. Admins must be managed server-side using the Firebase Admin SDK.
 * - Public vs. Private Data: Structural segregation is used to protect data. Public
 *   collections (/portfolioProjects, /blogPosts) are open for reads, while private
 *   collections (/contactMessages) are locked down. This is more secure and performant for
 *   list queries than using a boolean flag within a single collection.
 * - Contact Form Submissions: A special exception is made for the /contactMessages
 *   collection to allow any user (even unauthenticated ones) to create a document.
 *   This is necessary for a public contact form to function. However, all other
 *   access (read, update, delete) is strictly limited to administrators.
 *
 * @section Denormalization for Authorization
 * The use of the /roles_admin collection is a deliberate denormalization strategy. Instead
 * of checking a 'role' field on a user's profile, we perform a direct and efficient lookup
 * using `exists()`. This avoids complex and slow multi-document reads in rules and provides
 * a centralized place to manage administrative roles.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Checks if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user is an administrator.
     * Admin status is granted if a document with the user's UID exists in the
     * /roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Controls access to portfolio project documents. These are public for
     *              all visitors to read, but can only be created, modified, or
     *              deleted by an administrator.
     * @path /portfolioProjects/{projectId}
     * @allow (get, list) An anonymous visitor can read a specific project or list all projects.
     * @deny (create) A signed-in, non-admin user cannot create a new project.
     * @principle Implements a "Public Read, Admin Write" access pattern.
     */
    match /portfolioProjects/{projectId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Controls access to blog post documents. These are public for all
     *              visitors to read, but can only be created, modified, or deleted
     *              by an administrator.
     * @path /blogPosts/{blogPostId}
     * @allow (get, list) Any user, signed-in or not, can read blog posts.
     * @deny (update) A signed-in user who is not an admin cannot update an existing post.
     * @principle Implements a "Public Read, Admin Write" access pattern.
     */
    match /blogPosts/{blogPostId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Controls access to contact messages. Allows anyone to submit (create)
     *              a message, but restricts all read and management operations
     *              to administrators to protect submitter privacy.
     * @path /contactMessages/{contactMessageId}
     * @allow (create) An anonymous website visitor can submit the contact form.
     * @deny (get) A non-admin user cannot read a message, even if they know its ID.
     * @principle Enforces strict privacy by allowing public creation but restricting all other access to admins.
     */
    match /contactMessages/{contactMessageId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if true;
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages the collection of administrator roles. This collection acts as
     *              an access control list. To prevent privilege escalation, it is
     *              read-only from the client. Admins must be added or removed
     *              server-side via the Admin SDK.
     * @path /roles_admin/{adminId}
     * @allow (get) An admin can check if a given user ID has admin privileges.
     * @deny (create, update, delete) No user, including other admins, can modify roles from the client.
     * @principle Secures the role management system by disabling all client-side writes.
     */
    match /roles_admin/{adminId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}